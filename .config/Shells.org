#+TITLE: Shell configuration files
#+PROPERTY: header-args:shell :tangle-mode (identity #o444) :mkdirp yes :noweb yes :emph '(("<<" ">>"))
#+STARTUP: overview

* Introduction

This file provides the source for all my shell startup scripts. Running =emacs --batch -l org --eval '(org-babel-tangle-file "~/.config/Shells.org")'= generates the following file structure:

| .local        |       |           |
| └──           | share |           |
| ├──           | bash  |           |
| │             | └──   | env       |
| ├──           | zsh   |           |
| │             | ├──   | .zlogout  |
| │             | ├──   | .zprofile |
| │             | ├──   | .zshenv   |
| │             | └──   | .zshrc    |
| └──           | shrc  |           |
| .bash_logout  |       |           |
| .bash_profile |       |           |
| .bashrc       |       |           |
| .profile      |       |           |

Several parts of this implementation, especially the details of [[#Setup]], are heavily influenced by  https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html. I recommend reading that post for further information.

Syntax highlighting of shell source blocks is broken by noweb references, so I use https://github.com/TobiasZawada/org-src-emph/ to fix it, adding the :emph header option.

* Setup

Every generated file will be prefixed with the following information:

#+name: intro
#+begin_src sh
  # Do not edit! This file was generated by .config/Shells.org
#+end_src

** Env

From the [[https://www.gnu.org/software/bash/manual/bash.html#Invoked-with-name-sh][Bash manual]],

#+begin_quote
When invoked as an interactive shell with the name =sh=, Bash looks for the variable =ENV=, expands its value if it is defined, and uses the expanded value as the name of a file to read and execute.
#+end_quote

We therefore point this variable to the script we want to run for interactive POSIX shells, which we will call the [[#shrc][shrc]].

#+begin_src shell :noweb-ref env

  # Setup script location for interactive POSIX shells
  export ENV=~/.local/share/shrc

#+end_src

Similarly, when Bash is used non-interactively to run a script, it looks for a startup file from =BASH_ENV=.

#+begin_src shell :noweb-ref env

  # Setup script for non-interactive bash shells
  export BASH_ENV=~/.local/share/bash/env

#+end_src

We point it to the file =.local/share/bash/env=, which will follow the structure

#+begin_src shell :shebang "#!/bin/env bash" :tangle TEST/.local/share/bash/env

  <<intro>>
  <<env>>
  <<bash-env>>

#+end_src

This variable is cleared as part of  [[#bash-login-setup][the setup for a Bash login shell]] so that these scripts are not called too many times. Code blocks containing the form =<<env>>= will expand to include the exports in this section. The next snippet ensures that my personal shell-agnostic environment variables will also be exported.

#+begin_src shell :noweb-ref env
  <<environment-variables>>
#+end_src

** Utility functions
:PROPERTIES:
:header-args: :noweb-ref env-functions
:END:

Taken wholesale from https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html.
These functions can be used to more safely manipulate variables such as =PATH=, since the naïve =PATH=$PATH:foo= also includes the current directory if =PATH= was previously empty.

Each of the three functions =pathremove=, =pathprepend= and =pathappend= have the same syntax. For example, to add =~/.scripts= to the end of =PATH=, run =pathappend ~/.scripts PATH=.

#+begin_src shell

  # Usage: indirect_expand PATH -> $PATH
  indirect_expand () {
      env | sed -n "s/^$1=//p"
  }

  pathremove () {
      local IFS=':'
      local newpath
      local dir
      local var=${2:-PATH}
      # Bash has ${!var}, but this is not portable.
      for dir in `indirect_expand "$var"`; do
          IFS=''
          if [ "$dir" != "$1" ]; then
              newpath=$newpath:$dir
          fi
      done
      export $var=${newpath#:}
  }

  pathprepend () {
      # if the path is already in the variable,
      # remove it so we can move it to the front
      pathremove "$1" "$2"
      #[ -d "${1}" ] || return
      local var="${2:-PATH}"
      local value=`indirect_expand "$var"`
      export ${var}="${1}${value:+:${value}}"
  }

  pathappend () {
      pathremove "${1}" "${2}"
      #[ -d "${1}" ] || return
      local var=${2:-PATH}
      local value=`indirect_expand "$var"`
      export $var="${value:+${value}:}${1}"
  }

#+end_src

** File initialisation

*** POSIX Shell

**** Login (.profile)

If =.bash_profile= is missing, then bash will source =.profile= instead.

#+begin_src shell :shebang "#!/bin/env sh" :tangle TEST/.profile

  <<intro>>
  <<env>>
  <<login>>

#+end_src

**** Interactive
:PROPERTIES:
:CUSTOM_ID: shrc
:END:

#+begin_src shell :shebang "#!/bin/env sh" :tangle TEST/.local/share/shrc

  <<intro>>
  <<interactive>>

#+end_src

*** Bash

**** Login
:PROPERTIES:
:CUSTOM_ID: bash-login-setup
:END:

#+begin_src shell :shebang "#!/bin/env bash" :tangle TEST/.bash_profile
  
  <<intro>>
  <<env>>
  <<bash-env>>

  # Prevent env and bash-env from being run later, since BASH_ENV is used for
  # non-login non-interactive shells. No export because child shells may be
  # non-login and non-interactive.
  BASH_ENV=

  <<login>>
  <<bash-login>>

  # Check if this is an interactive shell
  if [ "$PS1" ]; then
      <<bash-interactive>>
  fi

#+end_src

**** Interactive

#+begin_src shell :shebang "#!/bin/env bash" :tangle TEST/.bashrc

  <<intro>>
  <<env>>
  <<bash-env>>

  <<interactive>>
  <<bash-interactive>>
  
#+end_src

**** Logout

#+begin_src shell :shebang "#!/bin/env bash" :tangle TEST/.bash_logout

  <<intro>>
  <<logout>>
  <<bash-logout>>
  
#+end_src

*** Zsh

**** Env

#+begin_src shell :shebang "#!/bin/env zsh" :tangle TEST/.local/share/zsh/.zshenv

  <<intro>>
  <<env>>
  <<zsh-env>>

#+end_src

**** Login

#+begin_src shell :shebang "#!/bin/env zsh" :tangle TEST/.local/share/zsh/.zprofile

  <<intro>>
  <<login>>
  <<zsh-login>>

#+end_src

**** Interactive

#+begin_src shell :shebang "#!/bin/env zsh" :tangle TEST/.local/share/zsh/.zshrc

  <<intro>>
  <<interactive>>
  <<zsh-interactive>>
  
#+end_src

**** Logout

#+begin_src shell :shebang "#!/bin/env zsh" :tangle TEST/.local/share/zsh/.zlogout

  <<intro>>
  <<logout>>
  <<zsh-logout>>
  
#+end_src

* Shell-agnostic

** Environment variables
:PROPERTIES:
:header-args: :noweb-ref environment-variables
:END:

** Login
:PROPERTIES:
:header-args: :noweb-ref login
:END:

** Logout
:PROPERTIES:
:header-args: :noweb-ref logout
:END:

** Interactive
:PROPERTIES:
:header-args: :noweb-ref interactive
:END:

* Bash

** Environment variables
:PROPERTIES:
:header-args: :noweb-ref bash-env
:END:

** Login
:PROPERTIES:
:header-args: :noweb-ref bash-login
:END:

** Interactive
:PROPERTIES:
:header-args: :noweb-ref bash-interactive
:END:

** Logout
:PROPERTIES:
:header-args: :noweb-ref bash-logout
:END:

* Zsh

** Environment variables
:PROPERTIES:
:header-args: :noweb-ref zsh-env
:END:

** Login
:PROPERTIES:
:header-args: :noweb-ref zsh-login
:END:

** Interactive
:PROPERTIES:
:header-args: :noweb-ref zsh-interactive
:END:

** Logout
:PROPERTIES:
:header-args: :noweb-ref zsh-logout
:END:
